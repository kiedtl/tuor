(use* core)
(use* varvara)

(use std)
(use alloc)
(use vec)
(use net)

(use assets)

(enum LineType U8
	status
	heading
	text
	// link
	// list
	// quote
	// pre
)

(struct Line
	[type LineType]
	[data  @Opaque] // TODO: untagged unions
	[line      @U8]
)

(let buf (Of vec/Vector U8))
(let document (Of vec/Vector Line))

(word main ( -- ) [
	[ ( -- ) halt ] .Screen/vector deo
	[ (--) on-mouse halt ] .Mouse/vector deo

	alloc/init
	2048s @buf ;init-sized
	25s @document ;init-sized

	0xf07fs .System/r deo
	0xf0e0s .System/g deo
	0xf0c0s .System/b deo
	100s 8s * .Screen/width deo
	70s 8s * .Screen/height deo

	"gemini://geminiprotocol.net/" make-request
	parse-buf
	draw
])

(word parse-buf ( -- ) [
	0s @document ;shrink-to

	(let line-start @U8)

	// (newline-addr -- )
	(word process-line (@U8 -- ) [
		// Change the newline to a NUL
		0 swap-sb <-
		$line-start
		ldak
		(cond
			[ (-- Bool) @document :len -> 0= ] [
				drop
				0s (as @Opaque) .LineType/status
			]
			[ '# = ] [
				(r 0) // Heading level ctr
				(until [ '# <> ] [
						drop 1+ (r 1+) ldak
				])
				// Advance past space
				0x20 = (when [ 1+ ])
				(r move) (as @Opaque) .LineType/heading
			]
			[ drop 0s (as @Opaque) .LineType/text ]
		)
		@document ;add-return move
		(r copy) :type <-
		(r copy) :data <-
		(r move) :line <-
		//"Line: " print-string $line-start print-string nl
	])

	@buf :items ->
	dup @line-start <-
	ldak
	(while [ 0<> ] [
		0x0A = (when [
			dup process-line
			dup 1+ @line-start <-
		])
		1+ ldak
	]) 2drop
])

// ( url -- )
(word make-request (@U8 -- ) [
	0s @buf ;shrink-to

	dup parse-url

	(let conn net/ConnectArgs)
	@conn :host <-
	1965s @conn :port <-
	@conn .Net/connect deo

	.Net/status dei .Status/ok <> (when [
		drop
		"Connection failed!" print-string nl
		"Error code: " print-string
			.Net/status dei (as I8) print-dec
			nl
		return
	])

	dup std/strlen .Net/length deo
		.Net/send deo
	2s .Net/length deo
		"\r\n" .Net/send deo

	.Net/status dei .Status/ok <> (when [
		"Request failed!" print-string nl
		"Error code: " print-string
			.Net/status dei (as I8) print-dec
			nl
		return
	])

	(until [ ( -- Bool) .Net/status dei .Status/ok <> ] [
		@buf :len -> 256s + @buf ;ensure-capacity
		256s .Net/length deo
		@buf :len -> @buf :items -> + .Net/recv deo
		.Net/length dei @buf :len -> + @buf :len <-
	])
])

(word draw (--) [
	draw-mouse
	render
])

(word render (--) [
	0x1 .Screen/auto deo
	0s .Screen/x deo
	0s .Screen/y deo

	@document :items ->
	@document :len ->
	0s
	(until [ (U16 U16 -- Bool) = ] [
		// items len ind
		rot 2dup :
		// len ind items ptr
		(as @Line) // FIXME: shouldn't be necessary, : should cast for us
		dup :type ->
			(cond
				[ .LineType/heading = ] [
					drop
					dup :data -> (as U8)
					(until [ 0= ] [
						1- "#" draw-text
					])
					" " draw-text
					drop
				]
				// TODO: language: continue
				// [ .LineType/status = ] [ continue ]
				[ drop ]
			)
		:line ->
			draw-text
			draw-next-line
		// len ind items
		rot>
		// items len ind
		1+
	])
	3drop
])

(let last-space @U8)
(let last-space-screenx U16)

(word draw-next-line (--) [
	0s .Screen/x deo
	0s @last-space-screenx <-
	.Screen/y dei 12s + .Screen/y deo
])

(word draw-text (@U8 --) [
	dup @last-space <-
	0s @last-space-screenx <-

	copy
	ldak
	(while [ 0<> ] [
		.Screen/width dei 8s - .Screen/x dei <
			(when [
				$last-space

				// Ensure last whitespace wasn't beginning
				// of string
				dup (r copy) <>
				(when  [
					// Move past the actual space
					//
					// FIXME: handle multiple spaces in a row
					1+

					.Screen/x dei
					$last-space-screenx
					(while [ (U16 U16 -- Bool) <> ] [
						dup .Screen/x deo
						0x20 draw-char
						8s +
					]) 2drop
					rot-sbs drop
					swap-bs
				] [
					// It's the beginning... nevermind!
					drop
				])

				draw-next-line

				// TODO: continue
				drop ldak
			])

		// Record if the current char is whitespace
		dup is-whitespace (when [
			over-sb @last-space <-
			.Screen/x dei @last-space-screenx <-
		])

		// TODO: allow '\n' and '\t' literal
		(cond
			[ 0x0A = ] [ drop draw-next-line ]
			[ 0x09 = ] [ drop 0x20 draw-char ]
			[ draw-char ]
		)

		1+ ldak
	])
	2drop
	(r drop)
])

// TODO: optimize when cond bodies are the same
// TODO: (or) builtin
(word is-whitespace (Char8 -- Bool) [
	(cond
		[ 0x0A = ] [ t ]
		[ 0x09 = ] [ t ]
		[ 0x20 = ] [ t ]
		[ nil ]
	)
	nip
])

(word set-glyph-addr (U8 -- ) [
	32 + @assets/FONT : .Screen/addr deo
])

(word draw-char (U8 -- ) [
	set-glyph-addr
	0x01 .Screen/sprite deo
])

(word draw-char-inverse (U8 -- ) [
	set-glyph-addr
	0x04 .Screen/sprite deo
])

(word draw-mouse ( -- ) [
	(let oldx U16)
	(let oldy U16)

	0x0 .Screen/auto deo

	$oldx .Screen/x deo
	$oldy .Screen/y deo
	@assets/MOUSE .Screen/addr deo
	0x40 .Screen/sprite deo

	.Mouse/x dei dup @oldx <- .Screen/x deo
	.Mouse/y dei dup @oldy <- .Screen/y deo

	0x41 .Screen/sprite deo
])

(word on-frame ( -- ) [ ])

(word on-mouse ( -- ) [
	.Mouse/state dei 0= (when [
		draw
	] [
		// Button press
	])
])

// TODO: handle https://, gopher://, etc (will need strfind("://"))
// TODO: handle relative URLs
(word parse-url (@U8 -- @U8) [
	// TODO: ensure shadowing works correct, then rename this to "buf"
	(let mybuf [U8 32])

	// First move past the gemini://, if it's there
	dup "gemini://" std/strstartequ (when [
		ldak
		(until [ '/ = ] [
				drop 1+ ldak
		]) drop 1+ 1+
	])

	// Next, move into buffer so we can modify it
	// It's okay if stuff gets chopped off
	24s swap @mybuf std/memcpy
	dup 24s : 0 swap-sb <- // Set the NUL, just in case

	// Find the slash (or if it doesn't exist, the NUL
	ldak
	(until [ dup '/ = swap 0= or ] [
		drop 1+ ldak
	]) drop

	// Stop the string at the slash
	0 swap-sb <-

	@mybuf
	// TODO: should coerce
	(as @U8)
])
(test parse-url [
	"gemini://domain.com/foo/bar/baz.gmi" parse-url print-string
		(should stdout-eq "domain.com")

	"domain.com/foo/bar/baz.gmi" parse-url print-string
		(should stdout-eq "domain.com")

	"foo.domain.com" parse-url print-string
		(should stdout-eq "foo.domain.com")
])
