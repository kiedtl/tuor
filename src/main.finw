(use* core)
(use* varvara)

(use std)
(use alloc)
(use vec)
(use net)

(use assets)
(let buf (Of vec/Vector U8))

(word main ( -- ) [
	[ ( -- ) halt ] .Screen/vector deo
	[ (--) on-mouse halt ] .Mouse/vector deo

	0xf07fs .System/r deo
	0xf0e0s .System/g deo
	0xf0c0s .System/b deo
	100s 8s * .Screen/width deo
	70s 8s * .Screen/height deo

	alloc/init

	(let conn net/ConnectArgs)
	"geminiprotocol.net" @conn :host <-
	1965s @conn :port <-
	@conn .Net/connect deo
	.Net/status dei "connection status: " print-string (as I8) print-dec nl

	"gemini://geminiprotocol.net/\r\n"
		dup std/strlen .Net/length deo
		.Net/send deo
	.Net/status dei (as I8) "send status: " print-string print-dec nl

	4096s @buf ;init-sized

	(let tmpbuf [U8 4096s]) // TODO: optimize, append to buf directly

	.Net/status dei
	(until [ .Status/ok <> ] [
		drop

		4096s .Net/length deo // Need (len) builtin?
		@tmpbuf .Net/recv deo
		.Net/length dei
			dup @buf ;ensure-capacity
			// TODO: add append-slice (append-chunk?) to std
			dup
				@buf :len -> @buf :items -> :
					@tmpbuf swap std/memcpy drop
				@buf :len tuck -> + swap <-

		.Net/status dei
	])
	drop

	draw
])

// ( host url -- )
(word make-request (@U8 @U8 -- ) [
])

(word draw (--) [
	draw-mouse
	draw-text
])

(word draw-text (--) [
	0x1 .Screen/auto deo
	0s .Screen/x deo
	0s .Screen/y deo

	(let last-space @[U8])
	(let last-space-screenx U16)
	@buf :items -> @last-space <-
	0s @last-space-screenx <-

	(word next-line (--) [
		0s .Screen/x deo
		0s @last-space-screenx <-
		.Screen/y dei 12s + .Screen/y deo
	])

	@buf :items ->
	ldak
	(while [ 0<> ] [
		.Screen/width dei 8s - .Screen/x dei <
			(when [
				$last-space

				// Ensure last whitespace wasn't beginning
				// of string
				dup @buf :items -> <>
				(when  [
					// Move past the actual space
					//
					// FIXME: handle multiple spaces in a row
					1+

					.Screen/x dei
					$last-space-screenx
					(while [ (U16 U16 -- Bool) <> ] [
						dup .Screen/x deo
						0x20 draw-char
						8s +
					]) 2drop
					rot-sbs drop
					swap-bs
				] [
					// It's the beginning... nevermind!
					drop
				])

				next-line

				// TODO: continue
				drop ldak
			])

		// Record if the current char is whitespace
		dup is-whitespace (when [
			over-sb @last-space <-
			.Screen/x dei @last-space-screenx <-
		])

		// TODO: allow '\n' and '\t' literal
		(cond
			[ 0x0A = ] [ drop next-line ]
			[ 0x09 = ] [ drop 0x20 draw-char ]
			[ draw-char ]
		)

		1+ ldak
	])
	2drop
])

// TODO: optimize when cond bodies are the same
// TODO: (or) builtin
(word is-whitespace (Char8 -- Bool) [
	(cond
		[ 0x0A = ] [ t ]
		[ 0x09 = ] [ t ]
		[ 0x20 = ] [ t ]
		[ nil ]
	)
	nip
])

(word set-glyph-addr (U8 -- ) [
	32 + @assets/FONT : .Screen/addr deo
])

(word draw-char (U8 -- ) [
	set-glyph-addr
	0x01 .Screen/sprite deo
])

(word draw-char-inverse (U8 -- ) [
	set-glyph-addr
	0x04 .Screen/sprite deo
])

(word draw-mouse ( -- ) [
	(let oldx U16)
	(let oldy U16)

	0x0 .Screen/auto deo

	$oldx .Screen/x deo
	$oldy .Screen/y deo
	@assets/MOUSE .Screen/addr deo
	0x40 .Screen/sprite deo

	.Mouse/x dei dup @oldx <- .Screen/x deo
	.Mouse/y dei dup @oldy <- .Screen/y deo

	0x41 .Screen/sprite deo
])

(word on-frame ( -- ) [ ])

(word on-mouse ( -- ) [
	.Mouse/state dei 0= (when [
		draw
	] [
		// Button press
	])
])
